{"version":3,"file":"function.js","sources":["../src/function.ts"],"sourcesContent":["import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild, destroy, isDestroyed, isDestroying } from '@ember/destroyable';\n\nimport { TrackedAsyncData } from 'ember-async-data';\nimport { resource } from 'ember-resources';\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { resourceFactory, resource, use } from 'ember-resources';\n * import { trackedFunction }  from 'reactiveweb/function';\n * import { on } from '@ember/modifier';\n *\n * const Request = resourceFactory((idFn) => {\n *   return resource(({use}) => {\n *     let trackedRequest = use(trackedFunction(async () => {\n *       let id = idFn();\n *       let response = await fetch(`https://swapi.dev/api/people/${id}`);\n *       let data = await response.json();\n *\n *       return data; // { name: 'Luke Skywalker', ... }\n *     }));\n *\n *     return trackedRequest;\n *   });\n * });\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   request = use(this, Request(() => this.id));\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.current.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n */\nexport function trackedFunction<Return>(fn: () => Return): State<Return>;\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { trackedFunction }  from 'reactiveweb/function';\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   request = trackedFunction(this, async () => {\n *     let response = await fetch(`https://swapi.dev/api/people/${this.id}`);\n *     let data = await response.json();\n *\n *     return data; // { name: 'Luke Skywalker', ... }\n *   });\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n * _Note_, this example uses the proposed `<template>` syntax from the [First-Class Component Templates RFC][rfc-799]\n *\n * Also note that after an `await`, the `this` context should not be accessed as it could lead to\n * destruction/timing issues.\n *\n * [rfc-799]: https://github.com/emberjs/rfcs/pull/779\n *\n * @param {Object} context destroyable parent, e.g.: component instance aka \"this\"\n * @param {Function} fn the function to run with the return value available on .value\n */\nexport function trackedFunction<Return>(context: object, fn: () => Return): State<Return>;\n\nexport function trackedFunction<Return>(\n  ...args: Parameters<typeof directTrackedFunction<Return>> | Parameters<typeof classUsable<Return>>\n): State<Return> {\n  if (args.length === 1) {\n    return classUsable(...args);\n  }\n\n  if (args.length === 2) {\n    return directTrackedFunction(...args);\n  }\n\n  assert('Unknown arity: trackedFunction must be called with 1 or 2 arguments');\n}\n\nfunction classUsable<Return>(fn: () => Return) {\n  const state = new State(fn);\n\n  let destroyable = resource<State<Return>>(() => {\n    state.retry();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\nfunction directTrackedFunction<Return>(context: object, fn: () => Return) {\n  const state = new State(fn);\n\n  let destroyable = resource<State<Return>>(context, () => {\n    state.retry();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\n/**\n * State container that represents the asynchrony of a `trackedFunction`\n */\nexport class State<Value> {\n  @tracked data: TrackedAsyncData<Value> | null = null;\n  @tracked declare promise: Value;\n\n  #fn: () => Value;\n\n  constructor(fn: () => Value) {\n    this.#fn = fn;\n  }\n\n  get state(): TrackedAsyncData<Value>['state'] | 'UNSTARTED' {\n    return this.data?.state ?? 'UNSTARTED';\n  }\n\n  /**\n   * Initially true, and remains true\n   * until the underlying promise resolves or rejects.\n   */\n  get isPending() {\n    if (!this.data) return true;\n\n    return this.data.isPending ?? false;\n  }\n\n  /**\n   * Alias for `isResolved || isRejected`\n   */\n  get isFinished() {\n    return this.isResolved || this.isRejected;\n  }\n\n  /**\n   * Alias for `isFinished`\n   * which is in turn an alias for `isResolved || isRejected`\n   */\n  get isSettled() {\n    return this.isFinished;\n  }\n\n  /**\n   * Alias for `isPending`\n   */\n  get isLoading() {\n    return this.isPending;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has resolved\n   */\n  get isResolved() {\n    return this.data?.isResolved ?? false;\n  }\n\n  /**\n   * Alias for `isRejected`\n   */\n  get isError() {\n    return this.isRejected;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has errored\n   */\n  get isRejected() {\n    return this.data?.isRejected ?? false;\n  }\n\n  /**\n   * this.data may not exist yet.\n   *\n   * Additionally, prior iterations of TrackedAsyncData did\n   * not allow the accessing of data before\n   * .state === 'RESOLVED'  (isResolved).\n   *\n   * From a correctness standpoint, this is perfectly reasonable,\n   * as it forces folks to handle the states involved with async functions.\n   *\n   * The original version of `trackedFunction` did not use TrackedAsyncData,\n   * and did not have these strictnesses upon property access, leaving folks\n   * to be as correct or as fast/prototype-y as they wished.\n   *\n   * For now, `trackedFunction` will retain that flexibility.\n   */\n  get value(): Awaited<Value> | null {\n    if (this.data?.isResolved) {\n      // This is sort of a lie, but it ends up working out due to\n      // how promises chain automatically when awaited\n      return this.data.value as Awaited<Value>;\n    }\n\n    return null;\n  }\n\n  /**\n   * When the function passed to `trackedFunction` throws an error,\n   * that error will be the value returned by this property\n   */\n  get error() {\n    if (this.data?.state !== 'REJECTED') {\n      return null;\n    }\n\n    return this.data?.error ?? null;\n  }\n\n  /**\n   * Will re-invoke the function passed to `trackedFunction`\n   * this will also re-set some properties on the `State` instance.\n   * This is the same `State` instance as before, as the `State` instance\n   * is tied to the `fn` passed to `trackedFunction`\n   *\n   * `error` or `resolvedValue` will remain as they were previously\n   * until this promise resolves, and then they'll be updated to the new values.\n   */\n  retry = async () => {\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    // We've previously had data, but we're about to run-again.\n    // we need to do this again so `isLoading` goes back to `true` when re-running.\n    // NOTE: we want to do this _even_ if this.data is already null.\n    //       it's all in the same tracking frame and the important thing is taht\n    //       we can't *read* data here.\n    this.data = null;\n\n    // We need to invoke this before going async so that tracked properties are consumed (entangled with) synchronously\n    this.promise = this.#fn();\n\n    // TrackedAsyncData interacts with tracked data during instantiation.\n    // We don't want this internal state to entangle with `trackedFunction`\n    // so that *only* the tracked data in `fn` can be entangled.\n    await Promise.resolve();\n\n    if (this.data) {\n      let isUnsafe = isDestroyed(this.data) || isDestroying(this.data);\n\n      if (!isUnsafe) {\n        destroy(this.data);\n        this.data = null;\n      }\n    }\n\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    // TrackedAsyncData manages the destroyable child association for us\n    this.data = new TrackedAsyncData(this.promise);\n\n    return this.promise;\n  };\n}\n"],"names":["trackedFunction","args","length","classUsable","directTrackedFunction","assert","fn","state","State","destroyable","resource","retry","associateDestroyableChild","context","g","this","prototype","tracked","i","void 0","constructor","data","isPending","isFinished","isResolved","isRejected","isSettled","isLoading","isError","value","error","isDestroyed","isDestroying","promise","Promise","resolve","isUnsafe","destroy","TrackedAsyncData"],"mappings":"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"}